#!/usr/bin/env ys-0

require ys::taptest: :all

use: list-ops

# Though there are no specifications here for dealing with large lists,
# implementers may add tests for handling large lists to ensure that the
# solutions have thought about performance concerns.

test::
- name: Empty lists
  code: append([] [])
  want: []

- name: List to empty list
  code: append([] [1 2 3 4])
  want:
  - 1
  - 2
  - 3
  - 4

- name: Empty list to list
  code: append([1 2 3 4] [])
  want:
  - 1
  - 2
  - 3
  - 4

- name: Non-empty lists
  code: append([1 2] [2 3 4 5])
  want:
  - 1
  - 2
  - 2
  - 3
  - 4
  - 5

- name: Empty list
  code: concat([])
  want: []

- name: List of lists
  code: concat([[1 2] [3] [] [4 5 6]])
  want:
  - 1
  - 2
  - 3
  - 4
  - 5
  - 6

- name: List of nested lists
  code: concat([[[1] [2]] [[3]] [[]] [[4 5 6]]])
  want:
  - - 1
  - - 2
  - - 3
  - []
  - - 4
    - 5
    - 6

- name: Empty list
  code: filter([] "(x) -> x modulo 2 == 1")
  want: []

- name: Non-empty list
  code: filter([1 2 3 5] "(x) -> x modulo 2 == 1")
  want:
  - 1
  - 3
  - 5

- name: Empty list
  code: length([])
  want: 0

- name: Non-empty list
  code: length([1 2 3 4])
  want: 4

- name: Empty list
  code: map([] "(x) -> x + 1")
  want: []

- name: Non-empty list
  code: map([1 3 5 7] "(x) -> x + 1")
  want:
  - 2
  - 4
  - 6
  - 8

- name: Empty list
  code: foldl([] 2 "(x, y) -> x * y")
  want: 2

- name: Direction independent function applied to non-empty list
  code: foldl([1 2 3 4] 5 "(x, y) -> x + y")
  want: 15

- name: Direction dependent function applied to non-empty list
  code: foldl([2 5] 5 "(x, y) -> x / y")
  want: 0

- name: Empty list
  code: foldl([] 2 "(acc, el) -> el * acc")
  want: 2

- name: Direction independent function applied to non-empty list
  code: foldl([1 2 3 4] 5 "(acc, el) -> el + acc")
  want: 15

- name: Direction dependent function applied to non-empty list
  code: foldl([1 2 3 4] 24 "(acc, el) -> el / acc")
  want: 64

- name: Empty list
  code: foldr([] 2 "(x, y) -> x * y")
  want: 2

- name: Direction independent function applied to non-empty list
  code: foldr([1 2 3 4] 5 "(x, y) -> x + y")
  want: 15

- name: Direction dependent function applied to non-empty list
  code: foldr([2 5] 5 "(x, y) -> x / y")
  want: 2

- name: Empty list
  code: foldr([] 2 "(acc, el) -> el * acc")
  want: 2

- name: Direction independent function applied to non-empty list
  code: foldr([1 2 3 4] 5 "(acc, el) -> el + acc")
  want: 15

- name: Direction dependent function applied to non-empty list
  code: foldr([1 2 3 4] 24 "(acc, el) -> el / acc")
  want: 9

- name: Empty list
  code: reverse([])
  want: []

- name: Non-empty list
  code: reverse([1 3 5 7])
  want:
  - 7
  - 5
  - 3
  - 1

- name: List of lists is not flattened
  code: reverse([[1 2] [3] [] [4 5 6]])
  want:
  - - 4
    - 5
    - 6
  - []
  - - 3
  - - 1
    - 2

done: 28
